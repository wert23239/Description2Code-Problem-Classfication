given two sorted integer arrays nums and nums merge nums into nums as one sorted array note you may assume that nums has enough space size that is greater or equal to m n to hold additional elements from nums the number of elements initialized in nums and nums are m and n respectively
given a binary search tree bst convert it to a greater tree such that every key of the original bst is changed to the original key plus sum of all keys greater than the original key in bst example input the root of a binary search tree like this output the root of a greater tree like this
given a binary array find the maximum number of consecutive s in this array example input output explanation the first two digits or the last three digits are consecutive s the maximum number of consecutive s is note the input array will only contain and the length of input array is a positive integer and will not exceed
design a data structure that supports the following two operations void addword word bool search word search word can search a literal word or a regular expression string containing only letters a z or a means it can represent any one letter for example addword bad addword dad addword mad search pad false search bad true search ad true search b true note you may assume that all words are consist of lowercase letters a z click to show hint you should be familiar with how a trie works if not please work on this problem implement trie prefix tree first
given an unsorted array of integers find the length of the longest consecutive elements sequence for example given the longest consecutive elements sequence is return its length your algorithm should run in o n complexity
given a binary tree return the zigzag level order traversal of its nodes' values ie from left to right then right to left for the next level and alternate between for example given binary tree null null return its zigzag level order traversal as
rotate an array of n elements to the right by k steps for example with n and k the array is rotated to note try to come up as many solutions as you can there are at least different ways to solve this problem show hint hint could you do it in place with o extra space related problem reverse words in a string ii credits special thanks to freezen for adding this problem and creating all test cases
suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand i e might become you are given a target value to search if found in the array return its index otherwise return you may assume no duplicate exists in the array
given a linked list return the node where the cycle begins if there is no cycle return null note do not modify the linked list follow up can you solve it without using extra space
given an array of words and a length l format the text such that each line has exactly l characters and is fully left and right justified you should pack your words in a greedy approach that is pack as many words as you can in each line pad extra spaces ' ' when necessary so that each line has exactly l characters extra spaces between words should be distributed as evenly as possible if the number of spaces on a line do not divide evenly between words the empty slots on the left will be assigned more spaces than the slots on the right for the last line of text it should be left justified and no extra space is inserted between words for example words this is an example of text justification l return the formatted lines as this is an example of text justification note each word is guaranteed not to exceed l in length click to show corner cases corner cases a line other than the last line might contain only one word what should you do in this case in this case that line should be left justified
given an input string reverse the string word by word for example given s the sky is blue return blue is sky the update for c programmers try to solve it in place in o space click to show clarification clarification what constitutes a word a sequence of non space characters constitutes a word could the input string contain leading or trailing spaces yes however your reversed string should not contain leading or trailing spaces how about multiple spaces between two words reduce them to a single space in the reversed string
given an array of integers find out whether there are two distinct indices i and j in the array such that the absolute difference between nums i and nums j is at most t and the absolute difference between i and j is at most k
given an unsorted integer array find the first missing positive integer for example given return and return your algorithm should run in o n time and uses constant space
follow up for find minimum in rotated sorted array what if duplicates are allowed would this affect the run time complexity how and why suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand i e might become find the minimum element the array may contain duplicates
given a list rotate the list to the right by k places where k is non negative for example given null and k return null
median is the middle value in an ordered integer list if the size of the list is even there is no middle value so the median is the mean of the two middle value examples the median is the median is design a data structure that supports the following two operations void addnum int num add a integer number from the data stream to the data structure double findmedian return the median of all elements so far for example addnum addnum findmedian addnum findmedian credits special thanks to louis for adding this problem and creating all test cases
reverse a singly linked list click to show more hints hint a linked list can be reversed either iteratively or recursively could you implement both
given an array and a value remove all instances of that value in place and return the new length do not allocate extra space for another array you must do this in place with constant memory the order of elements can be changed it doesn't matter what you leave beyond the new length example given input array nums val your function should return length with the first two elements of nums being try two pointers did you use the property of the order of elements can be changed what happens when the elements to remove are rare
given a binary search tree with non negative values find the minimum absolute difference between values of any two nodes example input  output explanation the minimum absolute difference is which is the difference between and or between and note there are at least two nodes in this bst
merge two sorted linked lists and return it as a new list the new list should be made by splicing together the nodes of the first two lists
given a binary search tree bst find the lowest common ancestor lca of two given nodes in the bst according to the definition of lca on wikipedia “the lowest common ancestor is defined between two nodes v and w as the lowest node in t that has both v and w as descendants where we allow a node to be a descendant of itself ”  for example the lowest common ancestor lca of nodes and is another example is lca of nodes and is since a node can be a descendant of itself according to the lca definition
given an encoded string return it's decoded string the encoding rule is k encoded string where the encoded string inside the square brackets is being repeated exactly k times note that k is guaranteed to be a positive integer you may assume that the input string is always valid no extra white spaces square brackets are well formed etc furthermore you may assume that the original data does not contain any digits and that digits are only for those repeat numbers k for example there won't be input like a or examples s a bc return aaabcbc s a c return accaccacc s abc cd ef return abcabccdcdcdef
design a data structure that supports all following operations in average o time note duplicate elements are allowed insert val inserts an item val to the collection remove val removes an item val from the collection if present getrandom returns a random element from current collection of elements the probability of each element being returned is linearly related to the number of same value the collection contains example init an empty collection randomizedcollection collection new randomizedcollection inserts to the collection returns true as the collection did not contain collection insert inserts another to the collection returns false as the collection contained collection now contains collection insert inserts to the collection returns true collection now contains collection insert getrandom should return with the probability and returns with the probability collection getrandom removes from the collection returns true collection now contains collection remove getrandom should return and both equally likely collection getrandom
given a linked list reverse the nodes of a linked list k at a time and return its modified list k is a positive integer and is less than or equal to the length of the linked list if the number of nodes is not a multiple of k then left out nodes in the end should remain as it is you may not alter the values in the nodes only nodes itself may be changed only constant memory is allowed for example given this linked list for k you should return for k you should return
given n points on a d plane find the maximum number of points that lie on the same straight line
given a word you need to judge whether the usage of capitals in it is right or not we define the usage of capitals in a word to be right when one of the following cases holds all letters in this word are capitals like usa all letters in this word are not capitals like leetcode only the first letter in this word is capital if it has more than one letter like google otherwise we define that this word doesn't use capitals in a right way example input usa output true example input flag output false note the input will be a non empty word consisting of uppercase and lowercase latin letters
design a data structure that supports all following operations in average o time insert val inserts an item val to the set if not already present remove val removes an item val from the set if present getrandom returns a random element from current set of elements each element must have the same probability of being returned example init an empty set randomizedset randomset new randomizedset inserts to the set returns true as was inserted successfully randomset insert returns false as does not exist in the set randomset remove inserts to the set returns true set now contains randomset insert getrandom should return either or randomly randomset getrandom removes from the set returns true set now contains randomset remove was already in the set so return false randomset insert since is the only number in the set getrandom always return randomset getrandom
given two integers representing the numerator and denominator of a fraction return the fraction in string format if the fractional part is repeating enclose the repeating part in parentheses for example given numerator denominator return given numerator denominator return given numerator denominator return no scary math just apply elementary math knowledge still remember how to perform a long division try a long division on the repeating part is obvious now try do you see a pattern be wary of edge cases list out as many test cases as you can think of and test your code thoroughly credits special thanks to shangrila for adding this problem and creating all test cases
write a program to find the nth super ugly number super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k for example is the sequence of the first super ugly numbers given primes of size note is a super ugly number for any given primes the given numbers in primes are in ascending order k le n le primes i the nth super ugly number is guaranteed to fit in a bit signed integer credits special thanks to dietpepsi for adding this problem and creating all test cases
given an array of integers and an integer k you need to find the number of unique k diff pairs in the array here a k diff pair is defined as an integer pair i j where i and j are both numbers in the array and their absolute difference is k example input k output explanation there are two diff pairs in the array and although we have two s in the input we should only return the number of unique pairs example input k output explanation there are four diff pairs in the array and example input k output explanation there is one diff pair in the array note the pairs i j and j i count as the same pair the length of the array won't exceed all the integers in the given input belong to the range e e
given two non negative integers num and num represented as strings return the product of num and num note the length of both num and num is both num and num contains only digits both num and num does not contain any leading zero you must not use any built in biginteger library or convert the inputs to integer directly
you are given two non empty linked lists representing two non negative integers the digits are stored in reverse order and each of their nodes contain a single digit add the two numbers and return it as a linked list you may assume the two numbers do not contain any leading zero except the number itself input output
given a binary tree return the inorder traversal of its nodes' values for example given binary tree null return note recursive solution is trivial could you do it iteratively
given a singly linked list where elements are sorted in ascending order convert it to a height balanced bst
given a roman numeral convert it to an integer input is guaranteed to be within the range from to
the thief has found himself a new place for his thievery again there is only one entrance to this area called the root besides the root each house has one and only one parent house after a tour the smart thief realized that all houses in this place forms a binary tree it will automatically contact the police if two directly linked houses were broken into on the same night determine the maximum amount of money the thief can rob tonight without alerting the police example maximum amount of money the thief can rob example maximum amount of money the thief can rob credits special thanks to dietpepsi for adding this problem and creating all test cases
follow up for unique paths now consider if some obstacles are added to the grids how many unique paths would there be an obstacle and empty space is marked as and respectively in the grid for example there is one obstacle in the middle of a x grid as illustrated below the total number of unique paths is note m and n will be at most
given n pairs of parentheses write a function to generate all combinations of well formed parentheses for example given n a solution set is
given two strings s and t determine if they are isomorphic two strings are isomorphic if the characters in s can be replaced to get t all occurrences of a character must be replaced with another character while preserving the order of characters no two characters may map to the same character but a character may map to itself for example given egg add return true given foo bar return false given paper title return true note you may assume both s and t have the same length
merge k sorted linked lists and return it as one sorted list analyze and describe its complexity
evaluate the value of an arithmetic expression in reverse polish notation valid operators are each operand may be an integer or another expression some examples
sort a linked list in o n log n time using constant space complexity
given a binary tree flatten it to a linked list in place for example given the flattened tree should look like  click to show hints hints if you notice carefully in the flattened tree each node's right child points to the next node of a pre order traversal
given an absolute path for a file unix style simplify it for example path home home path a b c c click to show corner cases corner cases did you consider the case where path in this case you should return another corner case is the path might contain multiple slashes ' ' together such as home foo in this case you should ignore redundant slashes and return home foo
implement the following operations of a stack using queues push x push element x onto stack pop removes the element on top of the stack top get the top element empty return whether the stack is empty notes you must use only standard operations of a queue which means only push to back peek pop from front size and is empty operations are valid depending on your language queue may not be supported natively you may simulate a queue by using a list or deque double ended queue as long as you use only standard operations of a queue you may assume that all operations are valid for example no pop or top operations will be called on an empty stack credits special thanks to jianchao li fighter for adding this problem and all test cases
one way to serialize a binary tree is to use pre order traversal when we encounter a non null node we record the node's value if it is a null node we record using a sentinel value such as for example the above binary tree can be serialized to the string where represents a null node given a string of comma separated values verify whether it is a correct preorder traversal serialization of a binary tree find an algorithm without reconstructing the tree each comma separated value in the string must be either an integer or a character ' ' representing null pointer you may assume that the input format is always valid for example it could never contain two consecutive commas such as example return true example return false example return false credits special thanks to dietpepsi for adding this problem and creating all test cases
given an array of non negative integers you are initially positioned at the first index of the array each element in the array represents your maximum jump length at that position determine if you are able to reach the last index for example a return true a return false
given a singly linked list l l →l →…→ln →ln reorder it to l →ln→l →ln →l →ln →… you must do this in place without altering the nodes' values for example given reorder it to
given a binary tree and a sum determine if the tree has a root to leaf path such that adding up all the values along the path equals the given sum for example given the below binary tree and sum  return true as there exist a root to leaf path which sum is
given a m x n matrix if an element is set its entire row and column to do it in place click to show follow up follow up did you use extra space a straight forward solution using o mn space is probably a bad idea a simple improvement uses o m n space but still not the best solution could you devise a constant space solution
given an array of integers return indices of the two numbers such that they add up to a specific target you may assume that each input would have exactly one solution and you may not use the same element twice example given nums target because nums nums return
given a string s you are allowed to convert it to a palindrome by adding characters in front of it find and return the shortest palindrome you can find by performing this transformation for example given aacecaaa return aaacecaaa given abcd return dcbabcd credits special thanks to ifanchu for adding this problem and creating all test cases thanks to freezen for additional test cases
