given two strings s and t determine if they are isomorphic two strings are isomorphic if the characters in s can be replaced to get t all occurrences of a character must be replaced with another character while preserving the order of characters no two characters may map to the same character but a character may map to itself for example given egg add return true given foo bar return false given paper title return true note you may assume both s and t have the same length
given a sorted linked list delete all duplicates such that each element appear only once for example given return given return
given a list of unique words find all pairs of distinct indices i j in the given list so that the concatenation of the two words i e words i words j is a palindrome example given words bat tab cat return the palindromes are battab tabbat example given words abcd dcba lls s sssll return the palindromes are dcbaabcd abcddcba slls llssssll credits special thanks to dietpepsi for adding this problem and creating all test cases
given a binary search tree bst with duplicates find all the mode s the most frequently occurred element in the given bst assume a bst is defined as follows the left subtree of a node contains only nodes with keys less than or equal to the node's key the right subtree of a node contains only nodes with keys greater than or equal to the node's key both the left and right subtrees must also be binary search trees for example given bst null return note if a tree has more than one mode you can return them in any order follow up could you do that without using any extra space assume that the implicit stack space incurred due to recursion does not count
given a binary tree return the postorder traversal of its nodes' values for example given binary tree return note recursive solution is trivial could you do it iteratively
determine if a sudoku is valid according to sudoku puzzles the rules the sudoku board could be partially filled where empty cells are filled with the character ' ' a partially filled sudoku which is valid note a valid sudoku board partially filled is not necessarily solvable only the filled cells need to be validated
all dna is composed of a series of nucleotides abbreviated as a c g and t for example acgaattccg when studying dna it is sometimes useful to identify repeated sequences within the dna write a function to find all the letter long sequences substrings that occur more than once in a dna molecule for example given s aaaaacccccaaaaaccccccaaaaagggttt return aaaaaccccc cccccaaaaa
given numrows generate the first numrows of pascal's triangle for example given numrows return
say you have an array for which the ith element is the price of a given stock on day i if you were only permitted to complete at most one transaction ie buy one and sell one share of the stock design an algorithm to find the maximum profit example input output max difference not as selling price needs to be larger than buying price example input output in this case no transaction is done i e max profit
write a function that takes a string as input and reverse only the vowels of a string example given s hello return holle example given s leetcode return leotcede note the vowels does not include the letter y
remove all elements from a linked list of integers that have value val example given val return credits special thanks to mithmatt for adding this problem and creating all test cases
suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand i e might become find the minimum element you may assume no duplicate exists in the array
suppose leetcode will start its ipo soon in order to sell a good price of its shares to venture capital leetcode would like to work on some projects to increase its capital before the ipo since it has limited resources it can only finish at most k distinct projects before the ipo help leetcode design the best way to maximize its total capital after finishing at most k distinct projects you are given several projects for each project i it has a pure profit pi and a minimum capital of ci is needed to start the corresponding project initially you have w capital when you finish a project you will obtain its pure profit and the profit will be added to your total capital to sum up pick a list of at most k distinct projects from given projects to maximize your final capital and output your final maximized capital example input k w profits capital output explanation since your initial capital is you can only start the project indexed after finishing it you will obtain profit and your capital becomes with capital you can either start the project indexed or the project indexed since you can choose at most projects you need to finish the project indexed to get the maximum capital therefore output the final maximized capital which is note you may assume all numbers in the input are non negative integers the length of profits array and capital array will not exceed the answer is guaranteed to fit in a bit signed integer
given a sorted array remove the duplicates in place such that each element appear only once and return the new length do not allocate extra space for another array you must do this in place with constant memory for example given input array nums your function should return length with the first two elements of nums being and respectively it doesn't matter what you leave beyond the new length
find the contiguous subarray within an array containing at least one number which has the largest sum for example given the array the contiguous subarray has the largest sum click to show more practice more practice if you have figured out the o n solution try coding another solution using the divide and conquer approach which is more subtle
given a string and a string dictionary find the longest string in the dictionary that can be formed by deleting some characters of the given string if there are more than one possible results return the longest word with the smallest lexicographical order if there is no possible result return the empty string example input s abpcplea d ale apple monkey plea output apple example input s abpcplea d a b c output a note all the strings in the input will only contain lower case letters the size of the dictionary won't exceed the length of all the strings in the input won't exceed
given a singly linked list determine if it is a palindrome follow up could you do it in o n time and o space
given a string s find the longest palindromic substring in s you may assume that the maximum length of s is example input babad output bab note aba is also a valid answer example input cbbd output bb
note this is a companion problem to the system design problem design tinyurl tinyurl is a url shortening service where you enter a url such as https leetcode com problems design tinyurl and it returns a short url such as http tinyurl com e iak design the encode and decode methods for the tinyurl service there is no restriction on how your encode decode algorithm should work you just need to ensure that a url can be encoded to a tiny url and the tiny url can be decoded to the original url
say you have an array for which the ith element is the price of a given stock on day i design an algorithm to find the maximum profit you may complete at most two transactions note you may not engage in multiple transactions at the same time ie you must sell the stock before you buy again
given a complete binary tree count the number of nodes definition of a complete binary tree from wikipedia in a complete binary tree every level except possibly the last is completely filled and all nodes in the last level are as far left as possible it can have between and h nodes inclusive at the last level h
given a set of candidate numbers c without duplicates and a target number t find all unique combinations in c where the candidate numbers sums to t the same repeated number may be chosen from c unlimited number of times note all numbers including target will be positive integers the solution set must not contain duplicate combinations for example given candidate set and target a solution set is
given a string and an integer k you need to reverse the first k characters for every k characters counting from the start of the string if there are less than k characters left reverse all of them if there are less than k but greater than or equal to k characters then reverse the first k characters and left the other as original example input s abcdefg k output bacdfeg restrictions the string consists of lower english letters only length of the given string and k will in the range
given an array where elements are sorted in ascending order convert it to a height balanced bst
given a root node reference of a bst and a key delete the node with the given key in the bst return the root node reference possibly updated of the bst basically the deletion can be divided into two stages search for a node to remove if the node is found delete the node note time complexity should be o height of tree example root null key given key to delete is so we find the node with value and delete it one valid answer is null null shown in the following bst another valid answer is null null
given a matrix of m x n elements m rows n columns return all elements of the matrix in spiral order for example given the following matrix  you should return
given a string s consists of upper lower case alphabets and empty space characters ' ' return the length of last word in the string if the last word does not exist return note a word is defined as a character sequence consists of non space characters only for example given s hello world return
given a binary tree containing digits from only each root to leaf path could represent a number an example is the root to leaf path which represents the number find the total sum of all root to leaf numbers for example the root to leaf path represents the number the root to leaf path represents the number return the sum
compare two version numbers version and version if version gt version return if version lt version return otherwise return you may assume that the version strings are non empty and contain only digits and the character the character does not represent a decimal point and is used to separate number sequences for instance is not two and a half or half way to version three it is the fifth second level revision of the second first level revision here is an example of version numbers ordering lt lt lt credits special thanks to ts for adding this problem and creating all test cases
given a binary tree you need to compute the length of the diameter of the tree the diameter of a binary tree is the length of the longest path between any two nodes in a tree this path may or may not pass through the root example given a binary tree  return which is the length of the path or note the length of path between two nodes is represented by the number of edges between them
given a string which consists of lowercase or uppercase letters find the length of the longest palindromes that can be built with those letters this is case sensitive for example aa is not considered a palindrome here note assume the length of given string will not exceed example input abccccdd output explanation one longest palindrome that can be built is dccaccd whose length is
given a string which contains only lowercase letters remove duplicate letters so that every letter appear once and only once you must make sure your result is the smallest in lexicographical order among all possible results example given bcabc return abc given cbacdcbc return acdb credits special thanks to dietpepsi for adding this problem and creating all test cases
given an array of integers where ≤ a i ≤ n n size of array some elements appear twice and others appear once find all the elements of n inclusive that do not appear in this array could you do it without extra space and in o n runtime you may assume the returned list does not count as extra space example input output
given a nested list of integers represented as a string implement a parser to deserialize it each element is either an integer or a list whose elements may also be integers or other lists note you may assume that the string is well formed string is non empty string does not contain white spaces string contains only digits example given s you should return a nestedinteger object which contains a single integer example given s return a nestedinteger object containing a nested list with elements an integer containing value a nested list containing two elements i an integer containing value ii a nested list with one element a an integer containing value
say you have an array for which the ith element is the price of a given stock on day i design an algorithm to find the maximum profit you may complete as many transactions as you like ie buy one and sell one share of the stock multiple times however you may not engage in multiple transactions at the same time ie you must sell the stock before you buy again
given a pattern and a string str find if str follows the same pattern here follow means a full match such that there is a bijection between a letter in pattern and a non empty word in str examples pattern abba str dog cat cat dog should return true pattern abba str dog cat cat fish should return false pattern aaaa str dog cat cat dog should return false pattern abba str dog dog dog dog should return false notes you may assume pattern contains only lowercase letters and str contains lowercase letters separated by a single space credits special thanks to minglotus for adding this problem and creating all test cases
given an array of integers find if the array contains any duplicates your function should return true if any value appears at least twice in the array and it should return false if every element is distinct
given a singly linked list group all odd nodes together followed by the even nodes please note here we are talking about the node number and not the value in the nodes you should try to do it in place the program should run in o space complexity and o nodes time complexity example given null return null note the relative order inside both the even and odd groups should remain as it was in the input the first node is considered odd the second node even and so on credits special thanks to djangounchained for adding this problem and creating all test cases
given an array of integers return indices of the two numbers such that they add up to a specific target you may assume that each input would have exactly one solution and you may not use the same element twice example given nums target because nums nums return
given a list of hour clock time points in hour minutes format find the minimum minutes difference between any two time points in the list example input output note the number of time points in the given list is at least and won't exceed the input time is legal and ranges from to
given a non negative integer num represented as a string remove k digits from the number so that the new number is the smallest possible note the length of num is less than and will be ge k the given num does not contain any leading zero example input num k output explanation remove the three digits and to form the new number which is the smallest example input num k output explanation remove the leading and the number is note that the output must not contain leading zeroes example input num k output explanation remove all the digits from the number and it is left with nothing which is
given a binary tree find its maximum depth the maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node
given an input string reverse the string word by word for example given s the sky is blue return blue is sky the update for c programmers try to solve it in place in o space click to show clarification clarification what constitutes a word a sequence of non space characters constitutes a word could the input string contain leading or trailing spaces yes however your reversed string should not contain leading or trailing spaces how about multiple spaces between two words reduce them to a single space in the reversed string
you need to find the largest value in each row of a binary tree example input output
given an array s of n integers are there elements a b c and d in s such that a b c d target find all unique quadruplets in the array which gives the sum of target note the solution set must not contain duplicate quadruplets for example given array s and target a solution set is
find the kth largest element in an unsorted array note that it is the kth largest element in the sorted order not the kth distinct element for example given and k return note you may assume k is always valid ≤ k ≤ array's length credits special thanks to mithmatt for adding this problem and creating all test cases
given n how many structurally unique bst's binary search trees that store values n for example given n there are a total of unique bst's
given a triangle find the minimum path sum from top to bottom each step you may move to adjacent numbers on the row below for example given the following triangle the minimum path sum from top to bottom is i e note bonus point if you are able to do this using only o n extra space where n is the total number of rows in the triangle
reverse a linked list from position m to n do it in place and in one pass for example given null m and n return null note given m n satisfy the following condition ≤ m ≤ n ≤ length of list
given a binary tree return the level order traversal of its nodes' values ie from left to right level by level for example given binary tree null null return its level order traversal as
given a nested list of integers implement an iterator to flatten it each element is either an integer or a list whose elements may also be integers or other lists example given the list by calling next repeatedly until hasnext returns false the order of elements returned by next should be example given the list by calling next repeatedly until hasnext returns false the order of elements returned by next should be
given an index k return the kth row of the pascal's triangle for example given k return note could you optimize your algorithm to use only o k extra space
implement a basic calculator to evaluate a simple expression string the expression string contains only non negative integers operators and empty spaces the integer division should truncate toward zero you may assume that the given expression is always valid some examples  note do not use the eval built in library function credits special thanks to ts for adding this problem and creating all test cases
you are given two non empty linked lists representing two non negative integers the most significant digit comes first and each of their nodes contain a single digit add the two numbers and return it as a linked list you may assume the two numbers do not contain any leading zero except the number itself follow up what if you cannot modify the input lists in other words reversing the lists is not allowed example input output
merge two sorted linked lists and return it as a new list the new list should be made by splicing together the nodes of the first two lists
given a binary tree return the preorder traversal of its nodes' values for example given binary tree return note recursive solution is trivial could you do it iteratively
given a binary tree find the maximum path sum for this problem a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent child connections the path must contain at least one node and does not need to go through the root for example given the below binary tree return
reverse a singly linked list click to show more hints hint a linked list can be reversed either iteratively or recursively could you implement both
given an array with n objects colored red white or blue sort them so that objects of the same color are adjacent with the colors in the order red white and blue here we will use the integers and to represent the color red white and blue respectively note you are not suppose to use the library's sort function for this problem click to show follow up follow up a rather straight forward solution is a two pass algorithm using counting sort first iterate the array counting number of 's 's and 's then overwrite array with total number of 's then 's and followed by 's could you come up with an one pass algorithm using only constant space
evaluate the value of an arithmetic expression in reverse polish notation valid operators are each operand may be an integer or another expression some examples
given a non empty array of integers return the k most frequent elements for example given and k return note you may assume k is always valid ≤ k ≤ number of unique elements your algorithm's time complexity must be better than o n log n where n is the array's size
follow up for search in rotated sorted array what if duplicates are allowed would this affect the run time complexity how and why suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand i e might become write a function to determine if a given target is in the array the array may contain duplicates
given an array of integers le a i le n n size of array some elements appear twice and others appear once find all the elements that appear twice in this array could you do it without extra space and in o n runtime example input output
given two strings s and t write a function to determine if t is an anagram of s for example s anagram t nagaram return true s rat t car return false note you may assume the string contains only lowercase alphabets follow up what if the inputs contain unicode characters how would you adapt your solution to such case
given an array of words and a length l format the text such that each line has exactly l characters and is fully left and right justified you should pack your words in a greedy approach that is pack as many words as you can in each line pad extra spaces ' ' when necessary so that each line has exactly l characters extra spaces between words should be distributed as evenly as possible if the number of spaces on a line do not divide evenly between words the empty slots on the left will be assigned more spaces than the slots on the right for the last line of text it should be left justified and no extra space is inserted between words for example words this is an example of text justification l return the formatted lines as this is an example of text justification note each word is guaranteed not to exceed l in length click to show corner cases corner cases a line other than the last line might contain only one word what should you do in this case in this case that line should be left justified
given an unsorted integer array find the first missing positive integer for example given return and return your algorithm should run in o n time and uses constant space
count the number of segments in a string where a segment is defined to be a contiguous sequence of non space characters please note that the string does not contain any non printable characters example input hello my name is john output
you are given two arrays without duplicates nums and nums where nums ’s elements are subset of nums find all the next greater numbers for nums 's elements in the corresponding places of nums the next greater number of a number x in nums is the first greater number to its right in nums if it does not exist output for this number example input nums nums output explanation for number in the first array you cannot find the next greater number for it in the second array so output for number in the first array the next greater number for it in the second array is for number in the first array there is no next greater number for it in the second array so output example input nums nums output explanation for number in the first array the next greater number for it in the second array is for number in the first array there is no next greater number for it in the second array so output note all elements in nums and nums are unique the length of both nums and nums would not exceed
a city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance now suppose you are given the locations and height of all the buildings as shown on a cityscape photo figure a write a program to output the skyline formed by these buildings collectively figure b the geometric information of each building is represented by a triplet of integers li ri hi where li and ri are the x coordinates of the left and right edge of the ith building respectively and hi is its height it is guaranteed that ≤ li ri ≤ int max hi ≤ int max and ri li you may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height for instance the dimensions of all buildings in figure a are recorded as  the output is a list of key points red dots in figure b in the format of x y x y x y that uniquely defines a skyline a key point is the left endpoint of a horizontal line segment note that the last key point where the rightmost building ends is merely used to mark the termination of the skyline and always has zero height also the ground in between any two adjacent buildings should be considered part of the skyline contour for instance the skyline in figure b should be represented as  notes the number of buildings in any input list is guaranteed to be in the range the input list is already sorted in ascending order by the left x position li the output list must be sorted by the x position there must be no consecutive horizontal lines of equal height in the output skyline for instance  is not acceptable the three lines of height should be merged into one in the final output as such credits special thanks to stellari for adding this problem creating these two awesome images and all test cases
given a data stream input of non negative integers a a an summarize the numbers seen so far as a list of disjoint intervals for example suppose the integers from the data stream are then the summary will be  follow up what if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size credits special thanks to yunhong for adding this problem and creating most of the test cases
find the contiguous subarray within an array containing at least one number which has the largest product for example given the array the contiguous subarray has the largest product
given an array of n positive integers and a positive integer s find the minimal length of a contiguous subarray of which the sum ≥ s if there isn't one return instead for example given the array and s the subarray has the minimal length under the problem constraint click to show more practice more practice if you have figured out the o n solution try coding another solution of which the time complexity is o n log n credits special thanks to freezen for adding this problem and creating all test cases
given a non empty array of integers return the third maximum number in this array if it does not exist return the maximum number the time complexity must be in o n example input output explanation the third maximum is example input output explanation the third maximum does not exist so the maximum is returned instead example input output explanation note that the third maximum here means the third maximum distinct number both numbers with value are both considered as second maximum
given a circular array the next element of the last element is the first element of the array print the next greater number for every element the next greater number of a number x is the first greater number to its traversing order next in the array which means you could search circularly to find its next greater number if it doesn't exist output for this number example input output explanation the first 's next greater number is the number can't find next greater number the second 's next greater number needs to search circularly which is also note the length of given array won't exceed
serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer or transmitted across a network connection link to be reconstructed later in the same or another computer environment design an algorithm to serialize and deserialize a binary tree there is no restriction on how your serialization deserialization algorithm should work you just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure for example you may serialize the following tree  as null null just the same as how leetcode oj serializes a binary tree you do not necessarily need to follow this format so please be creative and come up with different approaches yourself note do not use class member global static variables to store states your serialize and deserialize algorithms should be stateless credits special thanks to louis for adding this problem and creating all test cases
a linked list is given such that each node contains an additional random pointer which could point to any node in the list or null return a deep copy of the list
given a binary tree find its minimum depth the minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node
given a binary search tree bst find the lowest common ancestor lca of two given nodes in the bst according to the definition of lca on wikipedia “the lowest common ancestor is defined between two nodes v and w as the lowest node in t that has both v and w as descendants where we allow a node to be a descendant of itself ”  for example the lowest common ancestor lca of nodes and is another example is lca of nodes and is since a node can be a descendant of itself according to the lca definition
given an array nums we call i j an important reverse pair if i lt j and nums i gt nums j you need to return the number of important reverse pairs in the given array example input output example input output note the length of the given array will not exceed all the numbers in the input array are in the range of bit integer
write a function to delete a node except the tail in a singly linked list given only access to that node supposed the linked list is and you are given the third node with value the linked list should become after calling your function
given an array nums there is a sliding window of size k which is moving from the very left of the array to the very right you can only see the k numbers in the window each time the sliding window moves right by one position for example given nums and k window position max   therefore return the max sliding window as note you may assume k is always valid ie ≤ k ≤ input array's size for non empty array follow up could you solve it in linear time how about using a data structure such as deque double ended queue the queue size need not be the same as the window’s size remove redundant elements and the queue should store only elements that need to be considered
given a non negative integer represented as a non empty array of digits plus one to the integer you may assume the integer do not contain any leading zero except the number itself the digits are stored such that the most significant digit is at the head of the list
given two strings s and t which consist of only lowercase letters string t is generated by random shuffling string s and then add one more letter at a random position find the letter that was added in t example input s abcd t abcde output e explanation 'e' is the letter that was added
given an array of non negative integers you are initially positioned at the first index of the array each element in the array represents your maximum jump length at that position determine if you are able to reach the last index for example a return true a return false
given n points on a d plane find the maximum number of points that lie on the same straight line
given an array of integers that is already sorted in ascending order find two numbers such that they add up to a specific target number the function twosum should return indices of the two numbers such that they add up to the target where index must be less than index please note that your returned answers both index and index are not zero based you may assume that each input would have exactly one solution and you may not use the same element twice input numbers target output index index
given an array of integers and an integer k find out whether there are two distinct indices i and j in the array such that nums i nums j and the absolute difference between i and j is at most k
given a string s and a string t find the minimum window in s which will contain all the characters in t in complexity o n for example s adobecodebanc t abc minimum window is banc note if there is no such window in s that covers all characters in t return the empty string if there are multiple such windows you are guaranteed that there will always be only one unique minimum window in s
given an integer array nums find the sum of the elements between indices i and j i le j inclusive the update i val function modifies nums by updating the element at index i to val example given nums sumrange update sumrange note the array is only modifiable by the update function you may assume the number of calls to update and sumrange function is distributed evenly
given a m x n matrix if an element is set its entire row and column to do it in place click to show follow up follow up did you use extra space a straight forward solution using o mn space is probably a bad idea a simple improvement uses o m n space but still not the best solution could you devise a constant space solution
given a linked list reverse the nodes of a linked list k at a time and return its modified list k is a positive integer and is less than or equal to the length of the linked list if the number of nodes is not a multiple of k then left out nodes in the end should remain as it is you may not alter the values in the nodes only nodes itself may be changed only constant memory is allowed for example given this linked list for k you should return for k you should return
find all possible combinations of k numbers that add up to a number n given that only numbers from to can be used and each combination should be a unique set of numbers example input k n output example input k n output  credits special thanks to mithmatt for adding this problem and creating all test cases
given a string sort it in decreasing order based on the frequency of characters example input tree output eert explanation 'e' appears twice while 'r' and 't' both appear once so 'e' must appear before both 'r' and 't' therefore eetr is also a valid answer example input cccaaa output cccaaa explanation both 'c' and 'a' appear three times so aaaccc is also a valid answer note that cacaca is incorrect as the same characters must be together example input aabb output bbaa explanation bbaa is also a valid answer but aabb is incorrect note that 'a' and 'a' are treated as two different characters
given a binary tree and a sum determine if the tree has a root to leaf path such that adding up all the values along the path equals the given sum for example given the below binary tree and sum  return true as there exist a root to leaf path which sum is
description count the number of prime numbers less than a non negative number n credits special thanks to mithmatt for adding this problem and creating all test cases let's start with a isprime function to determine if a number is prime we need to check if it is not divisible by any number less than n the runtime complexity of isprime function would be o n and hence counting the total prime numbers up to n would be o n could we do better as we know the number must not be divisible by any number n we can immediately cut the total iterations half by dividing only up to n could we still do better let's write down all of 's factors × × × × as you can see calculations of × and × are not necessary therefore we only need to consider factors up to radic n because if n is divisible by some number p then n p × q and since p le q we could derive that p le radic n our total runtime has now improved to o n which is slightly better is there a faster approach public int countprimes int n int count for int i i n i if isprime i count return count private boolean isprime int num if num return false loop's ending condition is i i num instead of i sqrt num to avoid repeatedly calling an expensive function sqrt for int i i i num i if num i return false return true the sieve of eratosthenes is one of the most efficient ways to find all prime numbers up to n but don't let that name scare you i promise that the concept is surprisingly simple sieve of eratosthenes algorithm steps for primes below sieve of eratosthenes animation by skopp is licensed under cc by we start off with a table of n numbers let's look at the first number we know all multiples of must not be primes so we mark them off as non primes then we look at the next number similarly all multiples of such as × × must not be primes so we mark them off as well now we look at the next number which was already marked off what does this tell you should you mark off all multiples of as well is not a prime because it is divisible by which means all multiples of must also be divisible by and were already marked off so we can skip immediately and go to the next number now all multiples of such as × × × × can be marked off there is a slight optimization here we do not need to start from × where should we start marking off in fact we can mark off multiples of starting at × because × was already marked off by multiple of similarly × was already marked off by multiple of therefore if the current number is p we can always mark off multiples of p starting at p then in increments of p p p p p now what should be the terminating loop condition it is easy to say that the terminating loop condition is p n which is certainly correct but not efficient do you still remember hint yes the terminating loop condition can be p radic n as all non primes ge radic n must have already been marked off when the loop terminates all the numbers in the table that are non marked are prime the sieve of eratosthenes uses an extra o n memory and its runtime complexity is o n log log n for the more mathematically inclined readers you can read more about its algorithm complexity on wikipedia public int countprimes int n boolean isprime new boolean n for int i i n i isprime i true loop's ending condition is i i n instead of i sqrt n to avoid repeatedly calling an expensive function sqrt for int i i i n i if isprime i continue for int j i i j n j i isprime j false int count for int i i n i if isprime i count return count
given an unsorted array of integers find the length of the longest consecutive elements sequence for example given the longest consecutive elements sequence is return its length your algorithm should run in o n complexity
you are given an n x n d matrix representing an image rotate the image by degrees clockwise follow up could you do this in place
given a linked list remove the nth node from the end of list and return its head for example given linked list and n after removing the second node from the end the linked list becomes note given n will always be valid try to do this in one pass
find the sum of all left leaves in a given binary tree example there are two left leaves in the binary tree with values and respectively return
given a binary tree check whether it is a mirror of itself ie symmetric around its center for example this binary tree is symmetric  but the following null null is not note bonus points if you could solve it both recursively and iteratively
given an array of non negative integers you are initially positioned at the first index of the array each element in the array represents your maximum jump length at that position your goal is to reach the last index in the minimum number of jumps for example given array a the minimum number of jumps to reach the last index is jump step from index to then steps to the last index note you can assume that you can always reach the last index
given n non negative integers representing the histogram's bar height where the width of each bar is find the area of largest rectangle in the histogram above is a histogram where width of each bar is given height the largest rectangle is shown in the shaded area which has area unit for example given heights return
given an array of integers and an integer k you need to find the number of unique k diff pairs in the array here a k diff pair is defined as an integer pair i j where i and j are both numbers in the array and their absolute difference is k example input k output explanation there are two diff pairs in the array and although we have two s in the input we should only return the number of unique pairs example input k output explanation there are four diff pairs in the array and example input k output explanation there is one diff pair in the array note the pairs i j and j i count as the same pair the length of the array won't exceed all the integers in the given input belong to the range e e
given a sequence of n integers a a an a pattern is a subsequence ai aj ak such that i j k and ai ak aj design an algorithm that takes a list of n numbers as input and checks whether there is a pattern in the list note n will be less than example input output false explanation there is no pattern in the sequence example input output true explanation there is a pattern in the sequence example input output true explanation there are three patterns in the sequence and
follow up for remove duplicates what if duplicates are allowed at most twice for example given sorted array nums your function should return length with the first five elements of nums being and it doesn't matter what you leave beyond the new length
given a binary tree imagine yourself standing on the right side of it return the values of the nodes you can see ordered from top to bottom for example given the following binary tree  you should return credits special thanks to amrsaqr for adding this problem and creating all test cases
given a binary tree determine if it is height balanced for this problem a height balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than
given a binary tree return the bottom up level order traversal of its nodes' values ie from left to right level by level from leaf to root for example given binary tree null null return its bottom up level order traversal as
given a binary tree find the leftmost value in the last row of the tree example input output example input output note you may assume the tree i e the given root node is not null
given a binary tree return the inorder traversal of its nodes' values for example given binary tree null return note recursive solution is trivial could you do it iteratively
implement an iterator over a binary search tree bst your iterator will be initialized with the root node of a bst calling next will return the next smallest number in the bst note next and hasnext should run in average o time and uses o h memory where h is the height of the tree credits special thanks to ts for adding this problem and creating all test cases
write a function to check whether an input string is a valid ipv address or ipv address or neither ipv addresses are canonically represented in dot decimal notation which consists of four decimal numbers each ranging from to separated by dots e g besides leading zeros in the ipv is invalid for example the address is invalid ipv addresses are represented as eight groups of four hexadecimal digits each group representing bits the groups are separated by colons for example the address db a a e is a valid one also we could omit some leading zeros among four hexadecimal digits and some low case characters in the address to upper case ones so db a a e is also a valid ipv address omit leading zeros and using upper cases however we don't replace a consecutive group of zero value with a single empty group using two consecutive colons to pursue simplicity for example db a a e is an invalid ipv address besides extra leading zeros in the ipv is also invalid for example the address db a a e is invalid note you may assume there is no extra space or special characters in the input string example input output ipv explanation this is a valid ipv address return ipv example input db a a e output ipv explanation this is a valid ipv address return ipv example input output neither explanation this is neither a ipv address nor a ipv address
given a set of distinct integers nums return all possible subsets note the solution set must not contain duplicate subsets for example if nums a solution is
implement strstr returns the index of the first occurrence of needle in haystack or if needle is not part of haystack
implement a basic calculator to evaluate a simple expression string the expression string may contain open and closing parentheses the plus or minus sign non negative integers and empty spaces you may assume that the given expression is always valid some examples note do not use the eval built in library function
invert a binary tree  to trivia this problem was inspired by this original tweet by max howell google of our engineers use the software you wrote homebrew but you can’t invert a binary tree on a whiteboard so fuck off
given a binary tree determine if it is a valid binary search tree bst assume a bst is defined as follows the left subtree of a node contains only nodes with keys less than the node's key the right subtree of a node contains only nodes with keys greater than the node's key both the left and right subtrees must also be binary search trees example binary tree return true example binary tree return false
you are given a string s and a list of words words that are all of the same length find all starting indices of substring s in s that is a concatenation of each word in words exactly once and without any intervening characters for example given s barfoothefoobarman words foo bar you should return the indices order does not matter
given an array of size n find the majority element the majority element is the element that appears more than lfloor n rfloor times you may assume that the array is non empty and the majority element always exist in the array credits special thanks to ts for adding this problem and creating all test cases
design a data structure that supports all following operations in average o time insert val inserts an item val to the set if not already present remove val removes an item val from the set if present getrandom returns a random element from current set of elements each element must have the same probability of being returned example init an empty set randomizedset randomset new randomizedset inserts to the set returns true as was inserted successfully randomset insert returns false as does not exist in the set randomset remove inserts to the set returns true set now contains randomset insert getrandom should return either or randomly randomset getrandom removes from the set returns true set now contains randomset remove was already in the set so return false randomset insert since is the only number in the set getrandom always return randomset getrandom
given a list of words return the words that can be typed using letters of alphabet on only one row's of american keyboard like the image below example input hello alaska dad peace output alaska dad note you may use one character in the keyboard more than once you may assume the input string will only contain letters of alphabet
write an efficient algorithm that searches for a value in an m x n matrix this matrix has the following properties integers in each row are sorted from left to right the first integer of each row is greater than the last integer of the previous row for example consider the following matrix  given target return true
given a binary tree and a sum find all root to leaf paths where each path's sum equals the given sum for example given the below binary tree and sum  return
given a collection of integers that might contain duplicates nums return all possible subsets note the solution set must not contain duplicate subsets for example if nums a solution is
given an array of n integers where n nums return an array output such that output i is equal to the product of all the elements of nums except nums i solve it without division and in o n for example given return follow up could you solve it with constant space complexity note the output array does not count as extra space for the purpose of space complexity analysis
given a binary tree return all root to leaf paths for example given the following binary tree all root to leaf paths are credits special thanks to jianchao li fighter for adding this problem and creating all test cases
given an array s of n integers are there elements a b c in s such that a b c find all unique triplets in the array which gives the sum of zero note the solution set must not contain duplicate triplets for example given array s a solution set is
serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer or transmitted across a network connection link to be reconstructed later in the same or another computer environment design an algorithm to serialize and deserialize a binary search tree there is no restriction on how your serialization deserialization algorithm should work you just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure the encoded string should be as compact as possible note do not use class member global static variables to store states your serialize and deserialize algorithms should be stateless
given a binary array find the maximum number of consecutive s in this array example input output explanation the first two digits or the last three digits are consecutive s the maximum number of consecutive s is note the input array will only contain and the length of input array is a positive integer and will not exceed
given a binary search tree with non negative values find the minimum absolute difference between values of any two nodes example input  output explanation the minimum absolute difference is which is the difference between and or between and note there are at least two nodes in this bst
you are given a binary tree in which each node contains an integer value find the number of paths that sum to a given value the path does not need to start or end at the root or a leaf but it must go downwards traveling only from parent nodes to child nodes the tree has no more than nodes and the values are in the range to example root null null sum return the paths that sum to are
in llp world there is a hero called teemo and his attacking can make his enemy ashe be in poisoned condition now given the teemo's attacking ascending time series towards ashe and the poisoning time duration per teemo's attacking you need to output the total time that ashe is in poisoned condition you may assume that teemo attacks at the very beginning of a specific time point and makes ashe be in poisoned condition immediately example input output explanation at time point teemo starts attacking ashe and makes ashe be poisoned immediately this poisoned status will last seconds until the end of time point and at time point teemo attacks ashe again and causes ashe to be in poisoned status for another seconds so you finally need to output example input output explanation at time point teemo starts attacking ashe and makes ashe be poisoned this poisoned status will last seconds until the end of time point however at the beginning of time point teemo attacks ashe again who is already in poisoned status since the poisoned status won't add up together though the second poisoning attack will still work at time point it will stop at the end of time point so you finally need to output note you may assume the length of given time series array won't exceed you may assume the numbers in the teemo's attacking time series and his poisoning time duration per attacking are non negative integers which won't exceed
given a string determine if it is a palindrome considering only alphanumeric characters and ignoring cases for example a man a plan a canal panama is a palindrome race a car is not a palindrome note have you consider that the string might be empty this is a good question to ask during an interview for the purpose of this problem we define empty string as valid palindrome
given a binary tree struct treelinknode treelinknode left treelinknode right treelinknode next populate each next pointer to point to its next right node if there is no next right node the next pointer should be set to null initially all next pointers are set to null note you may only use constant extra space you may assume that it is a perfect binary tree ie all leaves are at the same level and every parent has two children for example given the following perfect binary tree after calling your function the tree should look like null null null
you are playing the following bulls and cows game with your friend you write down a number and ask your friend to guess what the number is each time your friend makes a guess you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position called bulls and how many digits match the secret number but locate in the wrong position called cows your friend will use successive guesses and hints to eventually derive the secret number for example secret number friend's guess hint bull and cows the bull is the cows are and write a function to return a hint according to the secret number and friend's guess use a to indicate the bulls and b to indicate the cows in the above example your function should return a b please note that both secret number and friend's guess may contain duplicate digits for example secret number friend's guess in this case the st in friend's guess is a bull the nd or rd is a cow and your function should return a b you may assume that the secret number and your friend's guess only contain digits and their lengths are always equal credits special thanks to jeantimex for adding this problem and creating all test cases
given a string s and a non empty string p find all the start indices of p's anagrams in s strings consists of lowercase english letters only and the length of both strings s and p will not be larger than the order of output does not matter example input s cbaebabacd p abc output explanation the substring with start index is cba which is an anagram of abc the substring with start index is bac which is an anagram of abc example input s abab p ab output explanation the substring with start index is ab which is an anagram of ab the substring with start index is ba which is an anagram of ab the substring with start index is ab which is an anagram of ab
the count and say sequence is the sequence of integers beginning as follows  is read off as one or is read off as two s or is read off as one then one or given an integer n generate the nth sequence note the sequence of integers will be represented as a string
you are given two integer arrays nums and nums sorted in ascending order and an integer k define a pair u v which consists of one element from the first array and one element from the second array find the k pairs u v u v uk vk with the smallest sums example given nums nums k return the first pairs are returned from the sequence example given nums nums k return the first pairs are returned from the sequence  example given nums nums k return all possible pairs are returned from the sequence credits special thanks to elmirap and stefanpochmann for adding this problem and creating all test cases
given two integers representing the numerator and denominator of a fraction return the fraction in string format if the fractional part is repeating enclose the repeating part in parentheses for example given numerator denominator return given numerator denominator return given numerator denominator return no scary math just apply elementary math knowledge still remember how to perform a long division try a long division on the repeating part is obvious now try do you see a pattern be wary of edge cases list out as many test cases as you can think of and test your code thoroughly credits special thanks to shangrila for adding this problem and creating all test cases
given an integer n generate a square matrix filled with elements from to n in spiral order for example given n you should return the following matrix
sort a linked list in o n log n time using constant space complexity
implement next permutation which rearranges numbers into the lexicographically next greater permutation of numbers if such arrangement is not possible it must rearrange it as the lowest possible order ie sorted in ascending order the replacement must be in place do not allocate extra memory here are some examples inputs are in the left hand column and its corresponding outputs are in the right hand column
given the root of a tree you are asked to find the most frequent subtree sum the subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node including the node itself so what is the most frequent subtree sum value if there is a tie return all the values with the highest frequency in any order examples input return since all the values happen only once return all of them in any order examples input return since happens twice however only occur once note you may assume the sum of values in any subtree is in the range of bit signed integer
design a stack that supports push pop top and retrieving the minimum element in constant time push x push element x onto stack pop removes the element on top of the stack top get the top element getmin retrieve the minimum element in the stack example minstack minstack new minstack minstack push minstack push minstack push minstack getmin returns minstack pop minstack top returns minstack getmin returns
given a set of non overlapping intervals insert a new interval into the intervals merge if necessary you may assume that the intervals were initially sorted according to their start times example given intervals insert and merge in as example given insert and merge in as this is because the new interval overlaps with
given a collection of candidate numbers c and a target number t find all unique combinations in c where the candidate numbers sums to t each number in c may only be used once in the combination note all numbers including target will be positive integers the solution set must not contain duplicate combinations for example given candidate set and target a solution set is
follow up for unique paths now consider if some obstacles are added to the grids how many unique paths would there be an obstacle and empty space is marked as and respectively in the grid for example there is one obstacle in the middle of a x grid as illustrated below the total number of unique paths is note m and n will be at most
two elements of a binary search tree bst are swapped by mistake recover the tree without changing its structure note a solution using o n space is pretty straight forward could you devise a constant space solution
write an algorithm to determine if a number is happy a happy number is a number defined by the following process starting with any positive integer replace the number by the sum of the squares of its digits and repeat the process until the number equals where it will stay or it loops endlessly in a cycle which does not include those numbers for which this process ends in are happy numbers example nbsp is a happy number credits special thanks to mithmatt and ts for adding this problem and creating all test cases
given a sorted linked list delete all nodes that have duplicate numbers leaving only distinct numbers from the original list for example given return given return
you are given two non empty linked lists representing two non negative integers the digits are stored in reverse order and each of their nodes contain a single digit add the two numbers and return it as a linked list you may assume the two numbers do not contain any leading zero except the number itself input output
given an array s of n integers find three integers in s such that the sum is closest to a given number target return the sum of the three integers you may assume that each input would have exactly one solution for example given array s and target the sum that is closest to the target is
equations are given in the format a b k where a and b are variables represented as strings and k is a real number floating point number given some queries return the answers if the answer does not exist return example given a b b c queries are a c b a a e a a x x return the input is vector lt pair lt string string gt gt equations vector lt double gt amp values vector lt pair lt string string gt gt queries where equations size values size and the values are positive this represents the equations return vector lt double gt according to the example above equations a b b c values queries a c b a a e a a x x the input is always valid you may assume that evaluating the queries will result in no division by zero and there is no contradiction
implement the following operations of a stack using queues push x push element x onto stack pop removes the element on top of the stack top get the top element empty return whether the stack is empty notes you must use only standard operations of a queue which means only push to back peek pop from front size and is empty operations are valid depending on your language queue may not be supported natively you may simulate a queue by using a list or deque double ended queue as long as you use only standard operations of a queue you may assume that all operations are valid for example no pop or top operations will be called on an empty stack credits special thanks to jianchao li fighter for adding this problem and all test cases
the string paypalishiring is written in a zigzag pattern on a given number of rows like this you may want to display this pattern in a fixed font for better legibility p a h n a p l s i i g y i r and then read line by line pahnaplsiigyir write the code that will take a string and make this conversion given a number of rows string convert string text int nrows convert paypalishiring should return pahnaplsiigyir
given a collection of intervals merge all overlapping intervals for example given return
median is the middle value in an ordered integer list if the size of the list is even there is no middle value so the median is the mean of the two middle value examples the median is the median is design a data structure that supports the following two operations void addnum int num add a integer number from the data stream to the data structure double findmedian return the median of all elements so far for example addnum addnum findmedian addnum findmedian credits special thanks to louis for adding this problem and creating all test cases
write a program to find the node at which the intersection of two singly linked lists begins for example the following two linked lists a a → a ↘ c → c → c ↗ b b → b → b begin to intersect at node c notes if the two linked lists have no intersection at all return null the linked lists must retain their original structure after the function returns you may assume there are no cycles anywhere in the entire linked structure your code should preferably run in o n time and use only o memory credits special thanks to stellari for adding this problem and creating all test cases
given a string s you are allowed to convert it to a palindrome by adding characters in front of it find and return the shortest palindrome you can find by performing this transformation for example given aacecaaa return aaacecaaa given abcd return dcbabcd credits special thanks to ifanchu for adding this problem and creating all test cases thanks to freezen for additional test cases
given an array of integers find out whether there are two distinct indices i and j in the array such that the absolute difference between nums i and nums j is at most t and the absolute difference between i and j is at most k
given a word you need to judge whether the usage of capitals in it is right or not we define the usage of capitals in a word to be right when one of the following cases holds all letters in this word are capitals like usa all letters in this word are not capitals like leetcode only the first letter in this word is capital if it has more than one letter like google otherwise we define that this word doesn't use capitals in a right way example input usa output true example input flag output false note the input will be a non empty word consisting of uppercase and lowercase latin letters
write a function to find the longest common prefix string amongst an array of strings
a robot is located at the top left corner of a m x n grid marked 'start' in the diagram below the robot can only move either down or right at any point in time the robot is trying to reach the bottom right corner of the grid marked 'finish' in the diagram below how many possible unique paths are there above is a x grid how many possible unique paths are there note m and n will be at most
one way to serialize a binary tree is to use pre order traversal when we encounter a non null node we record the node's value if it is a null node we record using a sentinel value such as for example the above binary tree can be serialized to the string where represents a null node given a string of comma separated values verify whether it is a correct preorder traversal serialization of a binary tree find an algorithm without reconstructing the tree each comma separated value in the string must be either an integer or a character ' ' representing null pointer you may assume that the input format is always valid for example it could never contain two consecutive commas such as example return true example return false example return false credits special thanks to dietpepsi for adding this problem and creating all test cases
given a linked list and a value x partition it such that all nodes less than x come before nodes greater than or equal to x you should preserve the original relative order of the nodes in each of the two partitions for example given and x return
given a non empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together you may assume the given string consists of lowercase english letters only and its length will not exceed example input abab output true explanation it's the substring ab twice example input aba output false example input abcabcabcabc output true explanation it's the substring abc four times and the substring abcabc twice
write a function that takes a string as input and returns the string reversed example given s hello return olleh
given preorder and inorder traversal of a tree construct the binary tree note you may assume that duplicates do not exist in the tree
given an array nums write a function to move all 's to the end of it while maintaining the relative order of the non zero elements for example given nums after calling your function nums should be note you must do this in place without making a copy of the array minimize the total number of operations credits special thanks to jianchao li fighter for adding this problem and creating all test cases
given a string containing just the characters ' ' ' ' ' ' ' ' ' ' and ' ' determine if the input string is valid the brackets must close in the correct order and are all valid but and are not
