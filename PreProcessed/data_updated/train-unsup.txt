given a non negative integer number num for every numbers i in the range le i le num calculate the number of 's in their binary representation and return them as an array example for num you should return follow up it is very easy to come up with a solution with run time o n sizeof integer but can you do it in linear time o n possibly in a single pass? space complexity should be o n can you do it like a boss? do it without using any builtin function like builtin popcount in c or in any other language you should make use of what you have produced already divide the numbers in ranges like and so on and try to generate new range from previous or does the odd even status of the number help you in calculating the number of s? credits special thanks to syedee for adding this problem and creating all test cases
given two words beginword and endword and a dictionary's word list find the length of shortest transformation sequence from beginword to endword such that only one letter can be changed at a time each transformed word must exist in the word list note that beginword is not a transformed word for example given beginword hit endword cog wordlist hot dot dog lot log cog as one shortest transformation is hit hot dot dog cog return its length note return if there is no such transformation sequence all words have the same length all words contain only lowercase alphabetic characters you may assume no duplicates in the word list you may assume beginword and endword are non empty and are not the same update the wordlist parameter had been changed to a list of strings instead of a set of strings please reload the code definition to get the latest changes
determine whether an integer is a palindrome do this without extra space click to show spoilers some hints could negative integers be palindromes? ie if you are thinking of converting the integer to string note the restriction of using extra space you could also try reversing an integer however if you have solved the problem reverse integer you know that the reversed integer might overflow how would you handle such case? there is a more generic way of solving this problem
given a string that consists of only uppercase english letters you can replace any letter in the string with another letter at most k times find the length of a longest substring containing all repeating letters you can get after performing the above operations note both the string's length and k will not exceed example input s abab k output explanation replace the two 'a's with two 'b's or vice versa example input s aababba k output explanation replace the one 'a' in the middle with 'b' and form aabbbba the substring bbbb has the longest repeating letters which is
given an integer n return n in lexicographical order for example given return please optimize your algorithm to use less time and space the input size may be as large as
design a stack that supports push pop top and retrieving the minimum element in constant time push x push element x onto stack pop removes the element on top of the stack top get the top element getmin retrieve the minimum element in the stack example minstack minstack new minstack minstack push minstack push minstack push minstack getmin returns minstack pop minstack top returns minstack getmin returns
implement a trie with insert search and startswith methods note you may assume that all inputs are consist of lowercase letters a z
a character in utf can be from to bytes long subjected to the following rules for byte character the first bit is a followed by its unicode code for n bytes character the first n bits are all one's the n bit is followed by n bytes with most significant bits being this is how the utf encoding would work char number range utf octet sequence hexadecimal binary  f xxxxxxx ff xxxxx xxxxxx ffff xxxx xxxxxx xxxxxx ffff xxx xxxxxx xxxxxx xxxxxx given an array of integers representing the data return whether it is a valid utf encoding note the input is an array of integers only the least significant bits of each integer is used to store the data this means each integer represents only byte of data example data which represents the octet sequence return true it is a valid utf encoding for a bytes character followed by a byte character example data which represented the octet sequence return false the first bits are all one's and the th bit is means it is a bytes character the next byte is a continuation byte which starts with and that's correct but the second continuation byte does not start with so it is invalid
all dna is composed of a series of nucleotides abbreviated as a c g and t for example acgaattccg when studying dna it is sometimes useful to identify repeated sequences within the dna write a function to find all the letter long sequences substrings that occur more than once in a dna molecule for example given s aaaaacccccaaaaaccccccaaaaagggttt return aaaaaccccc cccccaaaaa
a sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same for example these are arithmetic sequence the following sequence is not arithmetic a zero indexed array a consisting of n numbers is given a slice of that array is any pair of integers p q such that p q n a slice p q of array a is called arithmetic if the sequence a p a p a q a q is arithmetic in particular this means that p q the function should return the number of arithmetic slices in the array a example a return for arithmetic slices in a and itself
given an integer n count the total number of digit appearing in all non negative integers less than or equal to n for example given n return because digit occurred in the following numbers beware of overflow
implement a basic calculator to evaluate a simple expression string the expression string may contain open and closing parentheses the plus or minus sign non negative integers and empty spaces you may assume that the given expression is always valid some examples note do not use the eval built in library function
write a program to check whether a given number is an ugly number ugly numbers are positive numbers whose prime factors only include for example are ugly while is not ugly since it includes another prime factor note that is typically treated as an ugly number credits special thanks to jianchao li fighter for adding this problem and creating all test cases
the set n contains a total of n unique permutations by listing and labeling all of the permutations in order we get the following sequence ie for n given n and k return the kth permutation sequence note given n will be between and inclusive
design a data structure that supports the following two operations void addword word bool search word search word can search a literal word or a regular expression string containing only letters a z or a means it can represent any one letter for example addword bad addword dad addword mad search pad false search bad true search ad true search b true note you may assume that all words are consist of lowercase letters a z click to show hint you should be familiar with how a trie works if not please work on this problem implement trie prefix tree first
write a program that outputs the string representation of numbers from to n but for multiples of three it should output “fizz” instead of the number and for the multiples of five output “buzz” for numbers which are multiples of both three and five output “fizzbuzz” example n return fizz buzz fizz fizz buzz fizz fizzbuzz
implement atoi to convert a string to an integer hint carefully consider all possible input cases if you want a challenge please do not see below and ask yourself what are the possible input cases notes it is intended for this problem to be specified vaguely ie no given input specs you are responsible to gather all the input requirements up front update the signature of the c function had been updated if you still see your function signature accepts a const char argument please click the reload button to reset your code definition spoilers alert click to show requirements for atoi requirements for atoi the function first discards as many whitespace characters as necessary until the first non whitespace character is found then starting from this character takes an optional initial plus or minus sign followed by as many numerical digits as possible and interprets them as a numerical value the string can contain additional characters after those that form the integral number which are ignored and have no effect on the behavior of this function if the first sequence of non whitespace characters in str is not a valid integral number or if no such sequence exists because either str is empty or it contains only whitespace characters no conversion is performed if no valid conversion could be performed a zero value is returned if the correct value is out of the range of representable values int max or int min is returned
median is the middle value in an ordered integer list if the size of the list is even there is no middle value so the median is the mean of the two middle value examples the median is the median is given an array nums there is a sliding window of size k which is moving from the very left of the array to the very right you can only see the k numbers in the window each time the sliding window moves right by one position your job is to output the median array for each window in the original array for example given nums and k window position median  therefore return the median sliding window as note you may assume k is always valid ie ≤ k ≤ input array's size for non empty array
a binary watch has leds on the top which represent the hours and the leds on the bottom represent the minutes each led represents a zero or one with the least significant bit on the right for example the above binary watch reads given a non negative integer n which represents the number of leds that are currently on return all possible times the watch could represent example input n return note the order of output does not matter the hour must not contain a leading zero for example is not valid it should be the minute must be consist of two digits and may contain a leading zero for example is not valid it should be
convert a non negative integer to its english words representation given input is guaranteed to be less than for example one hundred twenty three twelve thousand three hundred forty five one million two hundred thirty four thousand five hundred sixty seven did you see a pattern in dividing the number into chunk of words? for example and group the number by thousands digits you can write a helper function that takes a number less than and convert just that chunk to words there are many edge cases what are some good test cases? does your code work with input such as ? or ? middle chunk is zero and should not be printed out
validate if a given string is numeric some examples true true abc false a false e true note it is intended for the problem statement to be ambiguous you should gather all requirements up front before implementing one update the signature of the c function had been updated if you still see your function signature accepts a const char argument please click the reload button to reset your code definition
given an integer write a function to determine if it is a power of three follow up could you do it without using any loop recursion? credits special thanks to dietpepsi for adding this problem and creating all test cases
note this is a companion problem to the system design problem design tinyurl tinyurl is a url shortening service where you enter a url such as https leetcode com problems design tinyurl and it returns a short url such as http tinyurl com e iak design the encode and decode methods for the tinyurl service there is no restriction on how your encode decode algorithm should work you just need to ensure that a url can be encoded to a tiny url and the tiny url can be decoded to the original url
given two non negative integers num and num represented as strings return the product of num and num note the length of both num and num is both num and num contains only digits both num and num does not contain any leading zero you must not use any built in biginteger library or convert the inputs to integer directly
given a string array words find the maximum value of length word i length word j where the two words do not share common letters you may assume that each word will contain only lower case letters if no such two words exist return example given abcw baz foo bar xtfn abcdef return the two words can be abcw xtfn example given a ab abc d cd bcd abcd return the two words can be ab cd example given a aa aaa aaaa return no such pair of words credits special thanks to dietpepsi for adding this problem and creating all test cases
given an integer write an algorithm to convert it to hexadecimal for negative integer two’s complement method is used note all letters in hexadecimal a f must be in lowercase the hexadecimal string must not contain extra leading s if the number is zero it is represented by a single zero character ' ' otherwise the first character in the hexadecimal string will not be the zero character the given number is guaranteed to fit within the range of a bit signed integer you must not use any method provided by the library which converts formats the number to hex directly example input output a example input output ffffffff
you have n super washing machines on a line initially each washing machine has some dresses or is empty for each move you could choose any m ≤ m ≤ n washing machines and pass one dress of each washing machine to one of its adjacent washing machines at the same time given an integer array representing the number of dresses in each washing machine from left to right on the line you should find the minimum number of moves to make all the washing machines have the same number of dresses if it is not possible to do it return example input output explanation st move nd move rd move example input output explanation st move nd move example input output explanation it's impossible to make all the three washing machines have the same number of dresses note the range of n is the range of dresses number in a super washing machine is e
find the length of the longest substring t of a given string consists of lowercase letters only such that every character in t appears no less than k times example input s aaabb k output the longest substring is aaa as 'a' is repeated times example input s ababbc k output the longest substring is ababb as 'a' is repeated times and 'b' is repeated times
design a data structure that supports all following operations in average o time insert val inserts an item val to the set if not already present remove val removes an item val from the set if present getrandom returns a random element from current set of elements each element must have the same probability of being returned example init an empty set randomizedset randomset new randomizedset inserts to the set returns true as was inserted successfully randomset insert returns false as does not exist in the set randomset remove inserts to the set returns true set now contains randomset insert getrandom should return either or randomly randomset getrandom removes from the set returns true set now contains randomset remove was already in the set so return false randomset insert since is the only number in the set getrandom always return randomset getrandom
given an integer return its base string representation example input output example input output note the input will be in range of e e
given an array of integers with possible duplicates randomly output the index of a given target number you can assume that the given target number must exist in the array note the array size can be very large solution that uses too much extra space will not pass the judge example int nums new int solution solution new solution nums pick should return either index or randomly each index should have equal probability of returning solution pick pick should return since in the array only nums is equal to solution pick
given two strings s and t which consist of only lowercase letters string t is generated by random shuffling string s and then add one more letter at a random position find the letter that was added in t example input s abcd t abcde output e explanation 'e' is the letter that was added
given a set of distinct integers nums return all possible subsets note the solution set must not contain duplicate subsets for example if nums a solution is
you are given two non empty linked lists representing two non negative integers the digits are stored in reverse order and each of their nodes contain a single digit add the two numbers and return it as a linked list you may assume the two numbers do not contain any leading zero except the number itself input output
given a set of distinct positive integers find the largest subset such that every pair si sj of elements in this subset satisfies si sj or sj si if there are multiple solutions return any subset is fine example nums result of course will also be ok example nums result credits special thanks to stomach ache for adding this problem and creating all test cases
given an array of integers every element appears three times except for one which appears exactly once find that single one note your algorithm should have a linear runtime complexity could you implement it without using extra memory?
given a range m n where m n return the bitwise and of all numbers in this range inclusive for example given the range you should return credits special thanks to amrsaqr for adding this problem and creating all test cases
find the nth digit of the infinite integer sequence note n is positive and will fit within the range of a bit signed integer n example input output example input output explanation the th digit of the sequence is a which is part of the number
given a positive integer n break it into the sum of at least two positive integers and maximize the product of those integers return the maximum product you can get for example given n return given n return note you may assume that n is not less than and not larger than there is a simple o n solution to this problem you may check the breaking results of n ranging from to to discover the regularities credits special thanks to jianchao li fighter for adding this problem and creating all test cases
divide two integers without using multiplication division and mod operator if it is overflow return max int
write a function that takes an unsigned integer and returns the number of ’ ' bits it has also known as the hamming weight for example the bit integer ’ ' has binary representation so the function should return credits special thanks to ts for adding this problem and creating all test cases
design a simplified version of twitter where users can post tweets follow unfollow another user and is able to see the most recent tweets in the user's news feed your design should support the following methods posttweet userid tweetid compose a new tweet getnewsfeed userid retrieve the most recent tweet ids in the user's news feed each item in the news feed must be posted by users who the user followed or by the user herself tweets must be ordered from most recent to least recent follow followerid followeeid follower follows a followee unfollow followerid followeeid follower unfollows a followee example twitter twitter new twitter user posts a new tweet id twitter posttweet user 's news feed should return a list with tweet id twitter getnewsfeed user follows user twitter follow user posts a new tweet id twitter posttweet user 's news feed should return a list with tweet ids tweet id should precede tweet id because it is posted after tweet id twitter getnewsfeed user unfollows user twitter unfollow user 's news feed should return a list with tweet id since user is no longer following user twitter getnewsfeed
for an integer n we call k a good base of n if all digits of n base k are now given a string representing n you should return the smallest good base of n in string format example input output explanation base is example input output explanation base is example input output explanation base is note the range of n is the string representing n is always valid and will not have leading zeros
design and implement a data structure for least frequently used lfu cache it should support the following operations get and put get key get the value will always be positive of the key if the key exists in the cache otherwise return put key value set or insert the value if the key is not already present when the cache reaches its capacity it should invalidate the least frequently used item before inserting a new item for the purpose of this problem when there is a tie i e two or more keys that have the same frequency the least recently used key would be evicted follow up could you do both operations in o time complexity? example lfucache cache new lfucache capacity cache put cache put cache get returns cache put evicts key cache get returns not found cache get returns cache put evicts key cache get returns not found cache get returns cache get returns
given an integer convert it to a roman numeral input is guaranteed to be within the range from to
given a nested list of integers implement an iterator to flatten it each element is either an integer or a list whose elements may also be integers or other lists example given the list by calling next repeatedly until hasnext returns false the order of elements returned by next should be example given the list by calling next repeatedly until hasnext returns false the order of elements returned by next should be
given a positive integer output its complement number the complement strategy is to flip the bits of its binary representation note the given integer is guaranteed to fit within the range of a bit signed integer you could assume no leading zero bit in the integer’s binary representation example input output explanation the binary representation of is no leading zero bits and its complement is so you need to output example input output explanation the binary representation of is no leading zero bits and its complement is so you need to output
given an integer write a function to determine if it is a power of two credits special thanks to jianchao li fighter for adding this problem and creating all test cases
given a roman numeral convert it to an integer input is guaranteed to be within the range from to
implement pow x n
given a string find the first non repeating character in it and return it's index if it doesn't exist return examples s leetcode return s loveleetcode return note you may assume the string contain only lowercase letters
given a positive integer n and you can do operations as follow if n is even replace n with n if n is odd you can replace n with either n or n what is the minimum number of replacements needed for n to become ? example input output explanation example input output explanation or
the hamming distance between two integers is the number of positions at which the corresponding bits are different given two integers x and y calculate the hamming distance note le x y lt example input x y output explanation ↑ ↑ the above arrows point to positions where the corresponding bits are different
now you are given a string s which represents a software license key which we would like to format the string s is composed of alphanumerical characters and dashes the dashes split the alphanumerical characters within the string into groups i e if there are m dashes the string is split into m groups the dashes in the given string are possibly misplaced we want each group of characters to be of length k except for possibly the first group which could be shorter but still must contain at least one character to satisfy this requirement we will reinsert dashes additionally all the lower case letters in the string must be converted to upper case so you are given a non empty string s representing a license key to format and an integer k and you need to return the license key formatted according to the description above example input s a r k k output a r k explanation the string s has been split into two parts each part has characters example input s a r k k output a r k explanation the string s has been split into three parts each part has characters except the first part as it could be shorter as said above note the length of string s will not exceed and k is a positive integer string s consists only of alphanumerical characters a z and or a z and or and dashes string s is non empty
design a data structure that supports all following operations in average o time note duplicate elements are allowed insert val inserts an item val to the collection remove val removes an item val from the collection if present getrandom returns a random element from current collection of elements the probability of each element being returned is linearly related to the number of same value the collection contains example init an empty collection randomizedcollection collection new randomizedcollection inserts to the collection returns true as the collection did not contain collection insert inserts another to the collection returns false as the collection contained collection now contains collection insert inserts to the collection returns true collection now contains collection insert getrandom should return with the probability and returns with the probability collection getrandom removes from the collection returns true collection now contains collection remove getrandom should return and both equally likely collection getrandom
your task is to calculate ab mod where a is a positive integer and b is an extremely large positive integer given in the form of an array example a b result example a b result credits special thanks to stomach ache for adding this problem and creating all test cases
given a non negative integer n count all numbers with unique digits x where le x lt n example given n return the answer should be the total numbers in the range of le x lt excluding a direct way is to use the backtracking approach backtracking should contains three states which are the current number number of steps to get that number and a bitmask which represent which number is marked as visited so far in the current number start with state and count all valid number till we reach number of steps equals to n this problem can also be solved using a dynamic programming approach and some knowledge of combinatorics let f k count of numbers with unique digits with length equals k f f k k the first factor is because a number cannot start with credits special thanks to memoryless for adding this problem and creating all test cases
given a non empty integer array of size n find the minimum number of moves required to make all array elements equal where a move is incrementing n elements by example input output explanation only three moves are needed remember each move increments two elements
median is the middle value in an ordered integer list if the size of the list is even there is no middle value so the median is the mean of the two middle value examples the median is the median is design a data structure that supports the following two operations void addnum int num add a integer number from the data stream to the data structure double findmedian return the median of all elements so far for example addnum addnum findmedian addnum findmedian credits special thanks to louis for adding this problem and creating all test cases
you are given two jugs with capacities x and y litres there is an infinite amount of water supply available you need to determine whether it is possible to measure exactly z litres using these two jugs if z liters of water is measurable you must have z liters of water contained within one or both buckets by the end operations allowed fill any of the jugs completely with water empty any of the jugs pour water from one jug into another till the other jug is completely full or the first jug itself is empty example from the famous die hard example input x y z output true example input x y z output false credits special thanks to vinod for adding this problem and creating all test cases
write a program to find the n th ugly number ugly numbers are positive numbers whose prime factors only include for example is the sequence of the first ugly numbers note that is typically treated as an ugly number and n does not exceed the naive approach is to call isugly for every number until you reach the nth one most numbers are not ugly try to focus your effort on generating only the ugly ones an ugly number must be multiplied by either or from a smaller ugly number the key is how to maintain the order of the ugly numbers try a similar approach of merging from three sorted lists l l and l assume you have uk the kth ugly number then uk must be min l l l credits special thanks to jianchao li fighter for adding this problem and creating all test cases
description count the number of prime numbers less than a non negative number n credits special thanks to mithmatt for adding this problem and creating all test cases let's start with a isprime function to determine if a number is prime we need to check if it is not divisible by any number less than n the runtime complexity of isprime function would be o n and hence counting the total prime numbers up to n would be o n could we do better? as we know the number must not be divisible by any number n we can immediately cut the total iterations half by dividing only up to n could we still do better? let's write down all of 's factors × × × × as you can see calculations of × and × are not necessary therefore we only need to consider factors up to radic n because if n is divisible by some number p then n p × q and since p le q we could derive that p le radic n our total runtime has now improved to o n which is slightly better is there a faster approach? public int countprimes int n int count for int i i n i if isprime i count return count private boolean isprime int num if num return false loop's ending condition is i i num instead of i sqrt num to avoid repeatedly calling an expensive function sqrt for int i i i num i if num i return false return true the sieve of eratosthenes is one of the most efficient ways to find all prime numbers up to n but don't let that name scare you i promise that the concept is surprisingly simple sieve of eratosthenes algorithm steps for primes below sieve of eratosthenes animation by skopp is licensed under cc by we start off with a table of n numbers let's look at the first number we know all multiples of must not be primes so we mark them off as non primes then we look at the next number similarly all multiples of such as × × must not be primes so we mark them off as well now we look at the next number which was already marked off what does this tell you? should you mark off all multiples of as well? is not a prime because it is divisible by which means all multiples of must also be divisible by and were already marked off so we can skip immediately and go to the next number now all multiples of such as × × × × can be marked off there is a slight optimization here we do not need to start from × where should we start marking off? in fact we can mark off multiples of starting at × because × was already marked off by multiple of similarly × was already marked off by multiple of therefore if the current number is p we can always mark off multiples of p starting at p then in increments of p p p p p now what should be the terminating loop condition? it is easy to say that the terminating loop condition is p n which is certainly correct but not efficient do you still remember hint ? yes the terminating loop condition can be p radic n as all non primes ge radic n must have already been marked off when the loop terminates all the numbers in the table that are non marked are prime the sieve of eratosthenes uses an extra o n memory and its runtime complexity is o n log log n for the more mathematically inclined readers you can read more about its algorithm complexity on wikipedia public int countprimes int n boolean isprime new boolean n for int i i n i isprime i true loop's ending condition is i i n instead of i sqrt n to avoid repeatedly calling an expensive function sqrt for int i i i n i if isprime i continue for int j i i j n j i isprime j false int count for int i i n i if isprime i count return count
additive number is a string whose digits can form additive sequence a valid additive sequence should contain at least three numbers except for the first two numbers each subsequent number in the sequence must be the sum of the preceding two for example is an additive number because the digits can form an additive sequence  is also an additive number the additive sequence is  note numbers in the additive sequence cannot have leading zeros so sequence or is invalid given a string containing only digits ' ' ' ' write a function to determine if it's an additive number follow up how would you handle overflow for very large input integers? credits special thanks to jeantimex for adding this problem and creating all test cases
given an array of integers a and let n to be its length assume bk to be an array obtained by rotating the array a k positions clock wise we define a rotation function f on a as follow f k bk bk n bk n calculate the maximum value of f f f n note n is guaranteed to be less than example a f f  f  f so the maximum value of f f f f is f
a magical string s consists of only ' ' and ' ' and obeys the following rules the string s is magical because concatenating the number of contiguous occurrences of characters ' ' and ' ' generates the string s itself the first few elements of string s is the following s …… if we group the consecutive ' 's and ' 's in s it will be and the occurrences of ' 's or ' 's in each group are you can see that the occurrence sequence above is the s itself given an integer n as input return the number of ' 's in the first n number in the magical string s note n will not exceed example input output explanation the first elements of magical string s is and it contains three 's so return
given a non empty integer array find the minimum number of moves required to make all array elements equal where a move is incrementing a selected element by or decrementing a selected element by you may assume the array's length is at most example input output explanation only two moves are needed remember each move increments or decrements one element
given two integers representing the numerator and denominator of a fraction return the fraction in string format if the fractional part is repeating enclose the repeating part in parentheses for example given numerator denominator return given numerator denominator return given numerator denominator return no scary math just apply elementary math knowledge still remember how to perform a long division? try a long division on the repeating part is obvious now try do you see a pattern? be wary of edge cases list out as many test cases as you can think of and test your code thoroughly credits special thanks to shangrila for adding this problem and creating all test cases
given n points on a d plane find the maximum number of points that lie on the same straight line
implement the following operations of a queue using stacks push x push element x to the back of queue pop removes the element from in front of queue peek get the front element empty return whether the queue is empty notes you must use only standard operations of a stack which means only push to top peek pop from top size and is empty operations are valid depending on your language stack may not be supported natively you may simulate a stack by using a list or deque double ended queue as long as you use only standard operations of a stack you may assume that all operations are valid for example no pop or peek operations will be called on an empty queue
design and implement a data structure for least recently used lru cache it should support the following operations get and put get key get the value will always be positive of the key if the key exists in the cache otherwise return put key value set or insert the value if the key is not already present when the cache reached its capacity it should invalidate the least recently used item before inserting a new item follow up could you do both operations in o time complexity? example lrucache cache new lrucache capacity cache put cache put cache get returns cache put evicts key cache get returns not found cache put evicts key cache get returns not found cache get returns cache get returns
given an d board count how many battleships are in it the battleships are represented with 'x's empty slots are represented with ' 's you may assume the following rules you receive a valid board made of only battleships or empty slots battleships can only be placed horizontally or vertically in other words they can only be made of the shape xn row n columns or nx n rows column where n can be of any size at least one horizontal or vertical cell separates between two battleships there are no adjacent battleships example x x x x in the above board there are battleships invalid example x xxxx x this is an invalid board that you will not receive as battleships will always have a cell separating between them follow up could you do it in one pass using only o extra memory and without modifying the value of the board?
implement an iterator over a binary search tree bst your iterator will be initialized with the root node of a bst calling next will return the next smallest number in the bst note next and hasnext should run in average o time and uses o h memory where h is the height of the tree credits special thanks to ts for adding this problem and creating all test cases
for a web developer it is very important to know how to design a web page's size so given a specific rectangular web page’s area your job by now is to design a rectangular web page whose length l and width w satisfy the following requirements the area of the rectangular web page you designed must equal to the given target area the width w should not be larger than the length l which means l w the difference between length l and width w should be as small as possible you need to output the length l and the width w of the web page you designed in sequence example input output explanation the target area is and all the possible ways to construct it are but according to requirement is illegal according to requirement is not optimal compared to so the length l is and the width w is note the given area won't exceed and is a positive integer the web page's width and length you designed must be positive integers
given two non negative integers num and num represented as string return the sum of num and num note the length of both num and num is both num and num contains only digits both num and num does not contain any leading zero you must not use any built in biginteger library or convert the inputs to integer directly
write a program to find the nth super ugly number super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k for example is the sequence of the first super ugly numbers given primes of size note is a super ugly number for any given primes the given numbers in primes are in ascending order k le n le primes i the nth super ugly number is guaranteed to fit in a bit signed integer credits special thanks to dietpepsi for adding this problem and creating all test cases
given a non negative integer num repeatedly add all its digits until the result has only one digit for example given num the process is like since has only one digit return it follow up could you do it without any loop recursion in o runtime? a naive implementation of the above process is trivial could you come up with other methods? what are all the possible results? how do they occur periodically or randomly? you may find this wikipedia article useful credits special thanks to jianchao li fighter for adding this problem and creating all test cases
given an array of numbers nums in which exactly two elements appear only once and all the other elements appear exactly twice find the two elements that appear only once for example given nums return note the order of the result is not important so in the above example is also correct your algorithm should run in linear runtime complexity could you implement it using only constant space complexity? credits special thanks to jianchao li fighter for adding this problem and creating all test cases
given a positive integer num write a function which returns true if num is a perfect square else false note do not use any built in library function such as sqrt example input returns true example input returns false credits special thanks to elmirap for adding this problem and creating all test cases
you are given an array x of n positive numbers you start at point and moves x metres to the north then x metres to the west x metres to the south x metres to the east and so on in other words after each move your direction changes counter clockwise write a one pass algorithm with o extra space to determine if your path crosses itself or not example given x ┌───┐ │ │ └───┼── │ return true self crossing example given x ┌──────┐ │ │ │ │ └──────────── return false not self crossing example given x ┌───┐ │ │ └───┼ return true self crossing credits special thanks to dietpepsi for adding this problem and creating all test cases
given an iterator class interface with methods next and hasnext design and implement a peekingiterator that support the peek operation it essentially peek at the element that will be returned by the next call to next here is an example assume that the iterator is initialized to the beginning of the list call next gets you the first element in the list now you call peek and it returns the next element calling next after that still return you call next the final time and it returns the last element calling hasnext after that should return false think of looking ahead you want to cache the next element is one variable sufficient? why or why not? test your design with call order of peek before next vs next before peek for a clean implementation check out google's guava library source code follow up how would you extend your design to be generic and work with all types not just integer? credits special thanks to porker for adding this problem and creating all test cases
there are n bulbs that are initially off you first turn on all the bulbs then you turn off every second bulb on the third round you toggle every third bulb turning on if it's off or turning off if it's on for the ith round you toggle every i bulb for the nth round you only toggle the last bulb find how many bulbs are on after n rounds example given n at first the three bulbs are off off off after first round the three bulbs are on on on after second round the three bulbs are on off on after third round the three bulbs are on off off so you should return because there is only one bulb is on
given a positive integer n find the least number of perfect square numbers for example which sum to n for example given n return because given n return because credits special thanks to jianchao li fighter for adding this problem and creating all test cases
serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer or transmitted across a network connection link to be reconstructed later in the same or another computer environment design an algorithm to serialize and deserialize a binary tree there is no restriction on how your serialization deserialization algorithm should work you just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure for example you may serialize the following tree  as null null just the same as how leetcode oj serializes a binary tree you do not necessarily need to follow this format so please be creative and come up with different approaches yourself note do not use class member global static variables to store states your serialize and deserialize algorithms should be stateless credits special thanks to louis for adding this problem and creating all test cases
you have a total of n coins that you want to form in a staircase shape where every k th row must have exactly k coins given n find the total number of full staircase rows that can be formed n is a non negative integer and fits within the range of a bit signed integer example n the coins can form the following rows ¤ ¤ ¤ ¤ ¤ because the rd row is incomplete we return example n the coins can form the following rows ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ because the th row is incomplete we return
write an algorithm to determine if a number is happy a happy number is a number defined by the following process starting with any positive integer replace the number by the sum of the squares of its digits and repeat the process until the number equals where it will stay or it loops endlessly in a cycle which does not include those numbers for which this process ends in are happy numbers example nbsp is a happy number credits special thanks to mithmatt and ts for adding this problem and creating all test cases
reverse bits of a given bits unsigned integer for example given input represented in binary as return represented in binary as  follow up if this function is called many times how would you optimize it? related problem reverse integer credits special thanks to ts for adding this problem and creating all test cases
given an unsorted array return whether an increasing subsequence of length exists or not in the array formally the function should return true if there exists i j k such that arr i lt arr j lt arr k given le i lt j lt k le n else return false your algorithm should run in o n time complexity and o space complexity examples given return true given return false credits special thanks to djangounchained for adding this problem and creating all test cases
given a list of non negative numbers and a target integer k write a function to check if the array has a continuous subarray of size at least that sums up to the multiple of k that is sums up to n k where n is also an integer example input k output true explanation because is a continuous subarray of size and sums up to example input k output true explanation because is an continuous subarray of size and sums up to note the length of the array won't exceed you may assume the sum of all the numbers is in the range of a signed bit integer
given two binary strings return their sum also a binary string for example a b return
given an integer signed bits write a function to check whether it is a power of example given num return true given num return false follow up could you solve it without loops recursion? credits special thanks to yukuairoy for adding this problem and creating all test cases
reverse digits of an integer example x return example x return click to show spoilers have you thought about this? here are some good questions to ask before coding bonus points for you if you have already thought through this if the integer's last digit is what should the output be? ie cases such as did you notice that the reversed integer might overflow? assume the input is a bit integer then the reverse of overflows how should you handle such cases? for the purpose of this problem assume that your function returns when the reversed integer overflows note the input is assumed to be a bit signed integer your function should return when the reversed integer overflows
calculate the sum of two integers a and b but you are not allowed to use the operator and example given a and b return credits special thanks to fujiaozhu for adding this problem and creating all test cases
given n axis aligned rectangles where n determine if they all together form an exact cover of a rectangular region each rectangle is represented as a bottom left point and a top right point for example a unit square is represented as coordinate of bottom left point is and top right point is example rectangles return true all rectangles together form an exact cover of a rectangular region example rectangles  return false because there is a gap between the two rectangular regions example rectangles  return false because there is a gap in the top center example rectangles  return false because two of the rectangles overlap with each other
given scores of n athletes find their relative ranks and the people with the top three highest scores who will be awarded medals gold medal silver medal and bronze medal example input output gold medal silver medal bronze medal explanation the first three athletes got the top three highest scores so they got gold medal silver medal and bronze medal for the left two athletes you just need to output their relative ranks according to their scores note n is a positive integer and won't exceed all the scores of athletes are guaranteed to be unique
suppose we abstract our file system by a string in the following manner the string dir n tsubdir n tsubdir n t tfile ext represents dir subdir subdir file ext the directory dir contains an empty sub directory subdir and a sub directory subdir containing a file file ext the string dir n tsubdir n t tfile ext n t tsubsubdir n tsubdir n t tsubsubdir n t t tfile ext represents dir subdir file ext subsubdir subdir subsubdir file ext the directory dir contains two sub directories subdir and subdir subdir contains a file file ext and an empty second level sub directory subsubdir subdir contains a second level sub directory subsubdir containing a file file ext we are interested in finding the longest number of characters absolute path to a file within our file system for example in the second example above the longest absolute path is dir subdir subsubdir file ext and its length is not including the double quotes given a string representing the file system in the above format return the length of the longest absolute path to file in the abstracted file system if there is no file in the system return note the name of a file contains at least a and an extension the name of a directory or sub directory will not contain a time complexity required o n where n is the size of the input string notice that a aa aaa file txt is not the longest file path if there is another path aaaaaaaaaaaaaaaaaaaaa sth png
implement int sqrt int x compute and return the square root of x
given a non empty array of numbers a a a … an where le ai find the maximum result of ai xor aj where le i j lt n could you do this in o n runtime? example input output explanation the maximum result is
given a positive integer return its corresponding column title as appear in an excel sheet for example a b c z aa ab credits special thanks to ifanchu for adding this problem and creating all test cases
given a matrix of m x n elements m rows n columns return all elements of the matrix in diagonal order as shown in the below image example input output explanation note the total number of elements of the given matrix will not exceed
given integers n and k find the lexicographically k th smallest integer in the range from to n note le k le n le example input n k output explanation the lexicographical order is  so the second smallest number is
given a non empty string containing an out of order english representation of digits output the digits in ascending order note input contains only lowercase english letters input is guaranteed to be valid and can be transformed to its original digits that means invalid inputs such as abc or zerone are not permitted input length is less than example input owoztneoer output example input fviefuro output
given an array of integers every element appears twice except for one find that single one note your algorithm should have a linear runtime complexity could you implement it without using extra memory?
given an array containing n distinct numbers taken from n find the one that is missing from the array for example given nums return note your algorithm should run in linear runtime complexity could you implement it using only constant extra space complexity? credits special thanks to jianchao li fighter for adding this problem and creating all test cases
find the total area covered by two rectilinear rectangles in a d plane each rectangle is defined by its bottom left corner and top right corner as shown in the figure assume that the total area is never beyond the maximum possible value of int credits special thanks to mithmatt for adding this problem creating the above image and all test cases
there is a list of sorted integers from to n starting from left to right remove the first number and every other number afterward until you reach the end of the list repeat the previous step again but this time from right to left remove the right most number and every other number from the remaining numbers we keep repeating the steps again alternating left to right and right to left until a single number remains find the last number that remains starting with a list of length n example input n output
implement a data structure supporting the following operations inc key inserts a new key with value or increments an existing key by key is guaranteed to be a non empty string dec key if key's value is remove it from the data structure otherwise decrements an existing key by if the key does not exist this function does nothing key is guaranteed to be a non empty string getmaxkey returns one of the keys with maximal value if no element exists return an empty string getminkey returns one of the keys with minimal value if no element exists return an empty string challenge perform all these in o time complexity
related to question excel sheet column title given a column title as appear in an excel sheet return its corresponding column number for example a gt b gt c gt z gt aa gt ab gt credits special thanks to ts for adding this problem and creating all test cases
implement the following operations of a stack using queues push x push element x onto stack pop removes the element on top of the stack top get the top element empty return whether the stack is empty notes you must use only standard operations of a queue which means only push to back peek pop from front size and is empty operations are valid depending on your language queue may not be supported natively you may simulate a queue by using a list or deque double ended queue as long as you use only standard operations of a queue you may assume that all operations are valid for example no pop or top operations will be called on an empty stack credits special thanks to jianchao li fighter for adding this problem and all test cases
shuffle a set of numbers without duplicates example init an array with set and int nums solution solution new solution nums shuffle the array and return its result any permutation of must equally likely to be returned solution shuffle resets the array back to its original configuration solution reset returns the random shuffling of array solution shuffle
given a singly linked list return a random node's value from the linked list each node must have the same probability of being chosen follow up what if the linked list is extremely large and its length is unknown to you? could you solve this efficiently without using extra space? example init a singly linked list listnode head new listnode head next new listnode head next next new listnode solution solution new solution head getrandom should return either or randomly each element should have equal probability of returning solution getrandom
given a non negative integer represented as a non empty array of digits plus one to the integer you may assume the integer do not contain any leading zero except the number itself the digits are stored such that the most significant digit is at the head of the list
the hamming distance between two integers is the number of positions at which the corresponding bits are different now your job is to find the total hamming distance between all pairs of the given numbers example input output explanation in binary representation the is is and is just showing the four bits relevant in this case so the answer will be hammingdistance hammingdistance hammingdistance note elements of the given array are in the range of to length of the array will not exceed
a password is considered strong if below conditions are all met it has at least characters and at most characters it must contain at least one lowercase letter at least one uppercase letter and at least one digit it must not contain three repeating characters in a row aaa is weak but aa a is strong assuming other conditions are met write a function strongpasswordchecker s that takes a string s as input and return the minimum change required to make s a strong password if s is already strong return insertion deletion or replace of any one character are all considered as one change
you are playing the following nim game with your friend there is a heap of stones on the table each time one of you take turns to remove to stones the one who removes the last stone will be the winner you will take the first turn to remove the stones both of you are very clever and have optimal strategies for the game write a function to determine whether you can win the game given the number of stones in the heap for example if there are stones in the heap then you will never win the game no matter or stones you remove the last stone will always be removed by your friend if there are stones in the heap could you figure out a way to remove the stones such that you will always be the winner? credits special thanks to jianchao li fighter for adding this problem and creating all test cases
given an array of size n find the majority element the majority element is the element that appears more than lfloor n rfloor times you may assume that the array is non empty and the majority element always exist in the array credits special thanks to ts for adding this problem and creating all test cases
given an integer n return the number of trailing zeroes in n note your solution should be in logarithmic time complexity credits special thanks to ts for adding this problem and creating all test cases
